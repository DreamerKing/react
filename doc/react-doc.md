# React 官方文档笔记

## JSX

JSX 是 JavaScript 的一个语法扩展，可以很好地描述 UI 应该呈现出它应有交互的本质形式，可以生成 React 元素。

在 JSX 中可以在大括号内放置任何有效的 JavaScript 表达式。JSX 本身也是一个表达式, 会被转换成 React.createElement()函数调用返回 JS 对象。

JSX 中指定属性：

1. 引号指定值为字符串的属性
2. 大括号插入 JS 表达式作为属性的值

不应对同一属性同时使用这两种形式。
JSX 采用小驼峰的形式定义属性名而不是 HTML 属性名称的全小写约定。

元素是构成 React 应用的最小单位，React DOM 负责更新 DOM 与 React 元素一致。
渲染 React 元素到 DOM

React.createRoot(dom).render(ReactElement)

React 元素是不可变对象。一旦被创建，就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。更新 UI 唯一的方式是创建一个全新的元素，并将其传入 root.render()。
React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。(只更新它需要更新的部分)

## 组件 & props

组件 可复用的代码片段

- 函数组件 接收一个属性对象作为参数，返回一个 React 元素。

- class 组件 可以使用 state 或生命周期方法等很多其他特性。

当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象称之为 props。

组件名称必须以大写字母开头,React 会将以小写字母开头的组件视为原生 DOM 标签。

组件无论是使用函数声明还是通过 class 声明，都绝不能修改自身的 props。(只读性)

## state & 生命周期

- state 是私有的，并且完全受控于当前组件,除了拥有并设置了它的组件，其他组件都无法访问。
- 不要直接修改 State，而应使用 setState(),构造函数是唯一可以给 state 赋值的地方。
- State 的更新可能是异步的，React 可能会把多个 setState() 调用合并成一个调用。this.props 和 this.state 可能会异步更新，不能依赖它们的值来更新下一个状态。解决这个问题可以向 setState 传一个函数，这个函数第一个参数为上一个 state, 第二个参数为被调用时的 props,返回下一个 state 对象。
- State 的更新会被合并 当调用 setState() 时，React 会把你提供的对象合并到当前的 state。但是这里的合并是浅合并。

数据是向下流动的 (单向数据流) 不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。组件可以选择把它的 state 作为 props 向下传递到它的子组件中。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。可以在有状态的组件中使用无状态的组件，反之亦然。

## 事件处理

React 元素与 DOM 元素事件处理的不同:

- React 事件的命名采用小驼峰式（camelCase），而不是纯小写。
- 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。
- 在 React 中不能通过返回 false 的方式阻止默认行为,必须显式地调用 preventDefault()。
- React 采用合成事件，无需担心跨浏览器兼容性问题。使用 React 时，一般不需要使用 addEventListener 为已创建的 DOM 元素添加监听器，只需要在该元素初始渲染的时候添加监听器即可。

class 的方法默认不会绑定 this，要关注一下在 JSX 中的回调函数 this 的指向。

- 使用 public class field 语法定义函数
- 在构造函数中使用 bind 方法绑定
- 在调用处使用匿名函数包裹 当函数作为 prop 传入子组件可能会进行额外的渲染。

向事件处理函数传递额外的参数通常通过箭头函数或 bind 方法进行。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。

## 条件渲染

- 在 render 使用流程控制语句
- 使用元素变量控制
- && 运算 （注意：falsy 表达式 会使 && 后面的元素被跳过，但会返回 falsy 表达式的值。）
- 三元运算符 ? true : false

在极少的情况下，可以让 render 方法直接返回 null，而不进行任何渲染,但这并不影响组件的生命周期。

## 列表 & key

key 帮助 React 识别元素的改变，比如被添加或删除。一个元素的 key 最好是这个元素所在列表中拥有的一个唯一的字符串。使用索引作为 key 在列表项顺序发生变化时，会导致性能变差，还可能引起组件状态的问题。如果不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。只有当列表不会重排和列表项状态不会改变，并且没有唯一的值可以做 key,才可使用索引作为 key。
元素的 key 只有放在就近的数组上下文中才有意义，并且在兄弟节点之间必须唯一。key 会传递信息给 React ，但不会传递给你的组件。

## 表单

受控组件 表单数据是由 React 组件来管理 可变状态通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。

非受控组件 表单数据将交由 DOM 节点来处理。

在 HTML 中, <textarea> 元素通过其子元素定义其文本，而在 React 中，<textarea> 使用 value 属性代替。

在 HTML 中，<select> 创建下拉列表标签。selected 属性用于标记选项被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。也可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项。

当需要处理多个 input 元素时，可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。

包含验证、追踪访问字段以及处理表单提交的完整解决方案：Formik。

非受控组件的默认值通过 defaultValue 属性，而不是 value。在组件已经挂载之后去更新 defaultValue 属性的值，不会造成 DOM 上值的更新。同样，<input type="checkbox"> 和 <input type="radio"> 支持 defaultChecked，<select> 和 <textarea> 支持 defaultValue。

在 HTML 中，<input type="file"> 可以让用户选择一个或多个文件上传到服务器，或者通过使用 File API 进行操作。
在 React 中，<input type="file" /> 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。

## 状态提升

多个组件需要反映相同的变化数据，可以将共享状态提升到最近的共同父组件中去。
